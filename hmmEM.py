from math import exp, logimport randomfrom time import timeimport numpy as npdef logmul(*args):	tot = 0	if max(args) == np.inf: return 0	for arg in args:		tot += arg	return totdef logadd(*args):	tot = 0	m = max(args)	if exp(m) == 0.0:		return m	else:		for arg in args:			tot += exp(arg - m)		return m + np.log(tot)def em(x, actions, numstates, numactions, opa, iters):	# Initialize T and O randomly	T = []	O = []	for a in range(numactions):		T.append([])		O.append([])		for i in range(numstates):			Tprobs = [random.random() for j in range(numstates)]			tot = sum(Tprobs)			T[-1].append(map(lambda p: p/tot, Tprobs))			Oprobs = [random.random() for j in range(opa[a])]			tot = sum(Oprobs)			O[-1].append(map(lambda p: p/tot, Oprobs))	# T = [[[0.7, 0.3], [0.4, 0.6]], [[0.9, 0.1], [0.2,0.8]]]	# O = [[[0.8, 0.2], [0., 1.]], [[1., 0.], [0.,1.]]]	pi = [1.0/numstates for i in range(numstates)]	for iteration in range(iters):		obsgammasum = [[[np.log(0) for o in range(opa[a])] for a in range(numactions)] for i in range(numstates)]		gammasum = [[np.log(0) for a in range(numactions)] for i in range(numstates)]		psisum = [[[np.log(0) for j in range(numstates)] for a in range(numactions)] for i in range(numstates)]		psigammasum = [[np.log(0) for a in range(numactions)] for i in range(numstates)]		for s in range(len(x)):			lentraj = len(x[s])			# Initialize alpha, beta, and gamma.  They will all be overwritten, except			# for beta[lentraj][i] == log(1), i.e. 0			alpha = [[0. for i in range(numstates)] for l in range(lentraj)]			beta = [[0. for i in range(numstates)] for l in range(lentraj)]			gamma = [[0. for i in range(numstates)] for l in range(lentraj)]			psi = [0. for l in range(lentraj - 1)]			for i in range(numstates):				alpha[0][i] = logmul(np.log(pi[i]), np.log(O[actions[s][0]][i][x[s][0]]))			for l in range(1, lentraj):				for j in range(numstates):					alphasum = np.log(0)					for i in range(numstates):						alphasum = logadd(alphasum, logmul(alpha[l - 1][i], np.log(T[actions[s][l]][i][j])))					alpha[l][j] = logmul(alphasum, np.log(O[actions[s][l]][j][x[s][l]]))			for l in range(lentraj - 2, -1, -1):				for i in range(numstates):					beta[l][i] = np.log(0)					for j in range(numstates):						beta[l][i] = logadd(beta[l][i], logmul(np.log(T[actions[s][l + 1]][i][j]), np.log(O[actions[s][l + 1]][j][x[s][l + 1]]), beta[l + 1][j]))						# Log Likelihood:  			# loglike should be the same loglike2 and they should decrease over time.			# Only works when there is only one trajectory.			# Need to update the computation for when there are multiple trajectories.			loglike = np.log(0)			loglike2 = np.log(0)			for i in range(numstates):				loglike = logadd(loglike, alpha[lentraj - 1][i])				loglike2 = logadd(loglike2, logmul(beta[0][i], np.log(pi[i]), np.log(O[actions[s][0]][i][x[s][0]])))						# print "loglike"			# print loglike			# print loglike2			# Computing gamma.			for l in range(lentraj):				gamma[l] = [logmul(alpha[l][i], beta[l][i]) for i in range(numstates)]				# Normalize gamma.				tot = logadd(*gamma[l])				gamma[l] = [logmul(gamma[l][i], -tot) for i in range(numstates)]				if l != lentraj - 1: 					# psi[l] = [[np.log(random.uniform(0, 0.01)) for j in range(numstates)] for i in range(numstates)]					psi[l] = [[logmul(gamma[l][i], np.log(T[actions[s][l + 1]][i][j]), np.log(O[actions[s][l + 1]][j][x[s][l + 1]]), beta[l + 1][j], -beta[l][i]) if beta[l][i] != np.log(0) else np.log(0) for j in range(numstates)] for i in range(numstates)]					# psi[l] = [[logadd(psi[l][i][j], logmul(gamma[l][i], np.log(T[actions[s][l + 1]][i][j]), np.log(O[actions[s][l + 1]][j][x[s][l + 1]]), beta[l + 1][j], -beta[l][i])) if beta[l][i] != np.log(0) else psi[l][i][j] for j in range(numstates)] for i in range(numstates)]					# tot = map(lambda e: logadd(*e), psi[l])					# psi[l] = [[logmul(psi[l][i][j], -tot[i]) for j in range(numstates)] for i in range(numstates)]					# print np.exp(psi[l])			for i in range(numstates):				# obsgammasum = [[np.log(0) for o in range(opa[a])] for a in range(numactions)]				# gammasum = [np.log(0) for a in range(numactions)]				# # obsgammasum = [[np.log(random.random()) for o in range(opa[a])] for a in range(numactions)]				# # gammasum = map(lambda e: logadd(*e), obsgammasum)				# psisum = [[np.log(0) for j in range(numstates)] for a in range(numactions)]				# tot = np.log(0)				# for lst in psisum:				# 	for e in lst:				# 		tot = logadd(tot, e)				# psisum = [[logmul(psisum[j][k], -tot, gammasum[j]) for k in range(numstates)] for j in range(numstates)]				for l in range(lentraj):					gammasum[i][actions[s][l]] = logadd(gammasum[i][actions[s][l]], gamma[l][i])					obsgammasum[i][actions[s][l]][x[s][l]] = logadd(obsgammasum[i][actions[s][l]][x[s][l]], gamma[l][i])					if l != lentraj - 1:						psisum[i][actions[s][l]] = [logadd(psisum[i][actions[s][l]][j], psi[l][i][j]) for j in range(numstates)]						psigammasum[i][actions[s][l]] = logadd(psigammasum[i][actions[s][l]], gamma[l][i])			O = [[[exp(logmul(obsgammasum[i][a][z], -gammasum[i][a])) for z in range(opa[a])] for i in range(numstates)] for a in range(numactions)]		T = [[[exp(logmul(psisum[i][a][j], -gammasum[i][a])) for j in range(numstates)] for i in range(numstates)] for a in range(numactions)]	return O# lensample = 10# samplesize = 1000# I = 1# d = 2# T = [[[0.7, 0.3], [0.4, 0.6]], [[0.9, 0.1], [0.2,0.8]]]# O = [[[0.8, 0.2], [0., 1.]], [[1., 0.], [0.,1.]]]# numactions = 2# numstates = 2# actions = [[0 for j in range(lensample)] for s in range(samplesize)]# obs = [[0 for j in range(lensample)] for s in range(samplesize)]# x = np.ones((lensample, d, samplesize))# for iter in range(I):#     print "Iteration: %d" %(iter + 1)#     # Generate data according to O and T.#     for s in range(samplesize):#     	state = 0#         for j in range(lensample):#             actions[s][j] = np.random.choice(numactions)#             state = np.random.choice(d, p = T[actions[s][j]][state])#             obs[s][j] = np.random.choice(d, p = O[actions[s][j]][state])# print actions# print em(obs, actions, numstates, numactions, [2, 2], 10)